# set global server name
ServerName ${HOSTNAME}

# set log to stdout/stderr
ErrorLog /dev/stderr
TransferLog /dev/stdout

# module
LoadModule request_module modules/mod_request.so

# set ssl session cache location
SSLSessionCache "shmcb:logs/ssl_cache(512000)"

# Nothing needs to be served over HTTP. This virtual host simply redirects to
# HTTPS.
<VirtualHost *:8080>
  DocumentRoot /var/www/html
  RewriteEngine On
  RewriteRule ^(.*)$ https://%{HTTP_HOST}$1 [R,L]
</VirtualHost>

<VirtualHost *:8443>
  # server name and aliases for SNI
  ServerName ${HOSTNAME}
  ServerAlias ${MASTER_PUBLIC_URL}

  # root where documents are served from
  DocumentRoot /var/www/html
  
  # enable the SSL engine and set the SSL TLS level and cipher suite
  SSLEngine on
  SSLProtocol +TLSv1.2
  SSLCipherSuite HIGH:!aNULL:!MD5
  SSLHonorCipherOrder on

  # set the certificate and private key for this service/route
  SSLCertificateFile /secrets/tls.crt
  SSLCertificateKeyFile /secrets/tls.key

  # This is the CA against which user's certificates will be checked.
  SSLCACertificateFile /piv/smartcard-ca.crt

  # set up variables and export them
  SSLUserName SSL_CLIENT_S_DN_CN
  SSLOptions +StdEnvVars +ExportCertData

  # used in the individial location segments below, not at the root
  #SSLVerifyClient require

  # max verification depth	
  SSLVerifyDepth 5 

  # trn on the proxy engine for the clients
  SSLProxyEngine on

  # created (as in the docs) by creating a proxy CA that is signed by the openshift master CA and then using that to create client crt and key for this node
  SSLProxyCACertificateFile /run/secrets/kubernetes.io/serviceaccount/ca.crt
  SSLProxyMachineCertificateFile /tmp/proxy_client.pem

  ErrorLog logs/ssl_error_log
  LogLevel debug
  CustomLog logs/ssl_request_log "%t %h %{SSL_PROTOCOL}x %{SSL_CIPHER}x \"%r\" %b"
  #TransferLog logs/ssl_access_log
  
  #LogLevel debug
  #CustomLog logs/ssl_request_log "%t %h %{SSL_PROTOCOL}x %{SSL_CIPHER}x \"%r\" %b"

  # Send all requests to the console
  RewriteEngine On
  RewriteRule ^/console(.*)$ https://%{HTTP_HOST}/console$1 [R,L]

  # In order to using the challenging-proxy an X-Csrf-Token must be present.
  RewriteCond %{REQUEST_URI} ^/challenging-proxy
  RewriteCond %{HTTP:X-Csrf-Token} ^$ [NC]
  RewriteRule ^.* - [F,L]

  # allow rewrite rules access to the lolower function
  RewriteMap lc int:tolower

  <Location /challenging-proxy/oauth/authorize>
    SSLVerifyClient require

    # authentication client id
    AuthName openshift
    # proxy back to authorize with the credential details
    ProxyPass https://${MASTER_PUBLIC_URL}/oauth/authorize
  </Location>

  <Location /login-proxy/oauth/authorize>
    SSLVerifyClient require

    # authentication client id
    AuthName openshift
    # proxy back to authorize with the credential details
    ProxyPass https://${MASTER_PUBLIC_URL}/oauth/authorize
  </Location>

  <ProxyMatch /oauth/authorize>
    SSLVerifyClient require

    #This require directive is very important
    require valid-user

    # rewrite the SSL_CLIENT_SAN_OTHER_msUPN_0 to lower case so that we can use it
    # for some reason in HTTPD 2.4.6 the ENV: reference won't work even with +StdEnvVars
    # and you need to use the SSL: reference
    # the variable looks like `abc1@agency.gov` from the smart card's certificate
    RewriteRule ^.* - [E=X_LOWER_USER:${lc:%{SSL:SSL_CLIENT_SAN_OTHER_msUPN_0}},L]
    
    # use the lower case variable from the cert (now `abc1@agency.gov`)
    RequestHeader set X-Remote-User "%{X_LOWER_USER}e" env=X_LOWER_USER
    
    # rewrite the above variable to strip the `@agency.gov` portion
    RequestHeader edit X-Remote-User "([^@]+)@.*" $1

  </ProxyMatch>
</VirtualHost>